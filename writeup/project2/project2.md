## project2

I will write this report according to the grading rubric, but not totally follow the points line-by-line.

---
**Key Auth One**
First auth accepts a user input string and then verifying it, in fact, the program will compare it with `GENERAL_HOTZ`, it is easily checked in gdb.
![one](one.png)

---
**Key Auth Two**
The second auth is AES-128-CBC encryption. User should specify the length of block and give the key with plain data. Similar to the previous step, key is `GENERAL_CROWELL` and the data should be `'KING CROWELL'`.
![two](two.png)

A trick here, required data is 12 bytes, but if I directly input it and terminate with a `'\n'`, comparison fails. Since the data is accepted by `fgets` which reads NULL byte as valid input, I append it at last.
```python
p.recvuntil('ENCRYPT:')
p.sendline('KING CROWELL\x00')
```

---
**Key Auth Three**
User is firstly required to give the session number appeared on the banner. The auth reveals completing a challenge: given 64 bytes and a timestamp, user should input 64 bytes in hex.

Naming the challenge string `challenge`, diving into the binary, there is a random buffer `randbuf`, and key `GENERAL_DOOM` used, saying `doom`. The expected user input should equal to the manipulated `rand_buf` after the following process:
> rand_buf ^= chllenge      // len(rand_buf) == 16
> rand_buf[0] ^= doom[0]
> rand_buf[5] ^= doom[1]
> rand_buf[10] ^= doom[2]
> rand_buf[15] ^= doom[3]

With the timestamp, it is easy to generate fixed random number. (However, the given time is useless, I generate one at the start of process)

---
**Nuke Checksum**
At step 4, user inputs a string which checksums to `0xdcdc59a9`.
![checksum](checksum.png)

The checksum algorithm is rather simple, just xor every double word. However, a trap occurs that the last entity is occupied by an `"\x00END"`, hence I should recover it (also by xor).
![trap](trap.png)

Crack the checksum is easy, since it is deterministic.

---
**Nuke Program**
The nuke program has some codes correspond to different actions:

|code|action|
|---|---|
|`DOOM`|trigger a paramtered function pointer|
|`DISARM`|trigger a non-paramtered function pointer|
|`END`|end reading nuke program|
|`I`|increase a stack pointer|
|`O`|output the byte at stack pointer|
|`S`|wrtie the next byte to the stack top|
|`R`|rewrite nuke program|

I have a chance to rewrite payload, so firstly I can use `I` and `O` to leak information, secondly use `I` and `S` to write exploit.

Two function pointers are leakable. Target machine is 32-bits, the offsets of segments (.text, libc, etc.) are fixed though ASLR is activated, so I can calculate any addresses from a single pointer. (vmmap is useful!)
![fp](fp.png)

The function pointers can be rewrite, after referencing other solutions, I use ROP with stack pivoting, if I trigger `DOOM`, the pivot can be set by swapping stack pointer with `edx`, luckily, such gadget exists in binary:
![pivot](pivot.png)

![flag](flag.png)
The flag is `th3_pr1nt_funct10n_w4s_100_l!n3s_al0ne`.

The easter egg is, if the shell is spwan from `system` lib call, then we will fall into a fake shell, forcing us to use ROP gadgets.
![fake](fake.png)
